/***************************************************************************************************
 * Author: Xin Wang
 * 
 * Description:
 * A.The agents decides which path to move, which package to deliver by themselves. The principle is
 * the agents choose the nearest package to deliver or the nearest unknown area to explore.
 * B.The agents communicate with each other when a.) they discovers a new package, b.) they decides to
 * pick up a package, c.) they actually picks up a package, and d.) they fails to drop off a package. 
 * 
 * Broadcast information:
 * A.agent id and location are broadcasted, so that others can infer which part of the area is unknown
 * and they need to explore these area (each agent remembers a map, those areas that have been explored
 * by itself or other agents will not be explored any more)
 * B.package id & location are broadcasted, so that others can infer which packages are discovered 
 * (each agent remembers a list of packages which are discovered either by themselves or by other agents.
 * the location of the package need to be considered as obstacle until they are successfully picked up by
 * an agent, the list of packages is remembered for the agents to choose from when they decide to pick
 * a package). When a package is reserved by an agent, the agent broadcasts a message so that others do 
 * not need to deliver it any more, the package information is therefore removed from the package list by
 * other agents). Once a package is picked up, the obstacle area becomes clear, every agent changes their
 * map. My assumption is when a package is discovered, everyone knows it and stores in their package table,
 * when a package is ordered, everyone removes from the package table, when it is picked up, everyone removes
 * from the map. This works well when the packages are delivered in destination successfully. On the other
 * hand, if a package are dropped in a place other than its destination, the agent treats this situation
 * as if the package just been discovered, the agent broadcast to other agents and other agents update their
 * map as well as the package table.)
 * 
 * Find package:
 * A.Use breadth first research to find the nearest package (in known area) or nearest unknown area to explore
 * Deliver package:
 * B.Use Astar algorithm to find the lowest value path
 * 
 * Problem detection:
 * A.If cannot make move in current situation, the agent begins to calculate how many times they are 
 * getting stuck. Once they found that they are stuck four times in the same place, the agents either drop 
 * the package or move randomly to get out of current blocked situation, then go to one destination of 
 * packages and reconsider which package to deliver(this helps to clear the destination area as soon as 
 * possible).
 **************************************************************************************************/

package xiw412;

import java.util.ArrayList;
import java.util.Random;

import agent.Action;
import agent.Agent;
import agent.Percept;
import pacworld.Direction;
import pacworld.Move;
import pacworld.PacPercept;
import pacworld.VisibleAgent;
import pacworld.VisiblePackage;
import pacworld.Pickup;
import pacworld.Dropoff;
import pacworld.Say;
import pacworld.Idle;

public class PacAgent extends Agent {

	PacAgent Pagent;
	PacPercept Pcept;
	VisiblePackage Vpack;
	
	int cor_cnt = 0;// how many times block in corner
	int bmp_x = -1;// bump position
	int bmp_y = -1;
	int counter = 0;
	int p_dir = -1;//if carry package, the direction of package
	public boolean bump = false;
	public VisibleAgent[] visAgents;
	public VisiblePackage[] visPackages;
	public String[] messages;
	public VisiblePackage heldPackage;
	public int worldSize;
	public int[] path;
	public tPackages ordered_package = null;
	
	public ArrayList<Action> moves = new ArrayList<Action>();// action array
																// generated by
																// Astar
																// algorithm

	int Ux = -1;// x and y positions of the unknown area
	int Uy = -1;

	public int[][] area;

	public ArrayList<tPackages> tabPackages = new ArrayList<tPackages>();// current
	// packages
	// table

	public ArrayList<PosCalc> dest = new ArrayList<PosCalc>();

	public ArrayList<tPackages> msgPackages = new ArrayList<tPackages>();// store
	// newly
	// found
	// packages
	// for
	// message
	// sending

	public int pid;// package id
	public int drop_x = -1;
	public int drop_y = -1;
	int current_x;// current position of agent
	int current_y;
	int last_x = -1;
	int last_y = -1;
	int drop_cnt = 0;//count how many times drop action happens in a roll
	String actions = "";// message string that describes actions
	public Astar findpath = null;

	public PosCalc endpos;
	public PosCalc startpos = new PosCalc(current_x, current_y);
	private BFS findbox = null;

	public Action last_action = null;
	int dropped_package = -1;

	public PacAgent(int id) {// set agent id
		this.id = Integer.toString(id);
	}

	public String getId() {
		return id;
	}
	
	PosCalc lastpos = new PosCalc(-1, -1);

	// whether there is obstacle in the position
	public boolean isObstacle(PosCalc currentPos) {
		if (area[currentPos.x][currentPos.y] == 2)
			return true;
		else
			return false;
	}

	// already visited or not
	public boolean isVisited(PosCalc currentPos) {
		if (area[currentPos.x][currentPos.y] == 1)
			return true;
		else
			return false;
	}

	// out of the worldSize or not
	public boolean isOutofbound(PosCalc currentPos) {
		if (currentPos.x < 0 || currentPos.x >= worldSize || currentPos.y < 0
				|| currentPos.y >= worldSize)
			return true;
		else
			return false;
	}

	// unknown
	public boolean isunKnown(PosCalc currentPos) {
		if (area[currentPos.x][currentPos.y] == 0)
			return true;
		else
			return false;
	}

	tPackages find_pac(int pid){
		for(int i = 0; i < tabPackages.size(); ++i){
			if(tabPackages.get(i).pid == pid)
				return tabPackages.get(i);
		}
		return null;
	}
	
	tPackages find_pac(int x, int y){
		for(int i = 0; i < tabPackages.size(); ++i){
			if(tabPackages.get(i).x == x && tabPackages.get(i).y == y)
				return tabPackages.get(i);
		}
		return null;
	}
	
	int count = 0;
	@Override
	public void see(Percept p) {
		// TODO Auto-generated method stub
		System.out.println("Round : " + count);
		// //////////////////////////////
		System.out.println("Agent: " + id);
		
		count++;
		Pcept = (PacPercept) p;
		Pcept.printPercept();

		bump = Pcept.feelBump();
		worldSize = Pcept.getWorldSize();// size of the square area
		heldPackage = Pcept.getHeldPackage();// package that is held by the

		// agent
		messages = Pcept.getMessages();// receive messages from other agents
		String mg = null;
		char msg_head;

		if (area == null)
			area = new int[worldSize][worldSize];// unvisited area is marked 0,
		// visited is marked 1

		for (int i = 0; i < messages.length; i++) {// parse messages received
			// from others
			/****************************************************************
			 * message format: package:
			 * P+i+packageID+x+xposition+y+yposition+o+isOrdered
			 * +p+isPicked+d+isDropped; agent:
			 * A+i+agentID+x+xposition+y+yposition
			 * +m+moves(E:east,W:west,S:south,
			 * N:north,P:pick(north),Q:pick(east):R:pick(south),O:pick(west))
			 ****************************************************************/

			mg = messages[i];// get messages from the message string

			msg_head = mg.charAt(0);
			String[] msg = new String[2];
			int ina = mg.indexOf("A");// index of character A
			int st = 0;
			int ed = 0;
			String ida = "";
			
			msg[0] = mg.substring(0, ina);
			msg[1] = mg.substring(ina+1);
			ida = mg.substring(msg[1].indexOf("i")+1, msg[1].indexOf("x"));

			if(ida == id)
				continue;
			
			if (msg_head == 'P') {// This message describes some newly detected
				// packages
				boolean containsP = false;

				while (!msg[0].isEmpty()) {
					st = msg[0].indexOf("i");//start position of package id
					ed = msg[0].indexOf("x");//x position of package 

					String msgs = msg[0].substring(st + 1, ed);
					pid = Integer.parseInt(msgs);
					st = ed;
					ed = msg[0].indexOf("y");//y position of package


					msgs = msg[0].substring(st + 1, ed);
					int x = Integer.parseInt(msgs);

					st = ed;
					ed = msg[0].indexOf("o");//whether the package has been ordered
					msgs = msg[0].substring(st + 1, ed);
					int y = Integer.parseInt(msgs);
					tPackages o = new tPackages(pid,x,y);
					if (area[x][y]==0){
						area[x][y] = 2;
						if(find_pac(pid) == null)
							tabPackages.add(o);
					}
					if(area[x][y] == 1){
						area[x][y] = 2;
						if(find_pac(pid) == null)
							tabPackages.add(o);
					}
					
					st = ed;
					ed = msg[0].indexOf("e");//end position of "true" or "false"
					boolean isOrdered = Boolean.parseBoolean(msg[0].substring(
							st + 1, ed + 1));
					if(isOrdered){
						tPackages s = find_pac(pid);
						if(s != null)
							tabPackages.remove(s);
					}
					
					st = msg[0].indexOf("p");//whether the package has been picked
					ed = msg[0].indexOf("e", st);
					boolean isPicked = Boolean.parseBoolean(msg[0].substring(
							st + 1, ed + 1));
					if (isPicked) {
						area[x][y] = 1;
					}
					
					msg[0] = msg[0].replace(msg[0].substring(0, ed + 1), "");

				}
			}

			if (ed > ina && ina > 0) {// information of the agent that sends the
				// message
				msg[1] = mg.substring(ina);
			}

			boolean containsA = false;
			if (msg[1] != null) {// the agent send message of its own recent
				st = msg[1].indexOf("i");
				ed = msg[1].indexOf("x");
				String msgs = msg[1].substring(st + 1, ed);
				
				st = ed;
				ed = msg[1].indexOf("y");
				msgs = msg[1].substring(st + 1, ed);
				int x = Integer.parseInt(msgs);
				
				st = ed;
				ed = msg[1].indexOf("m");
				msgs = msg[1].substring(st + 1, ed);
				int y = Integer.parseInt(msgs);

				for (int e = Math.max(0, x - 7); e <= Math.min(worldSize - 1,
						x + 7); e++) {// 15*15 area of the agent
					// is known

					for (int f = Math.max(0, y - 7); f <= Math.min(
							worldSize - 1, y + 7); f++) {

						if (area[e][f] == 0) {// mark the area to be known in
						// the map
							area[e][f] = 1;
						}
					}
				}
			}
		}

		//end receiving messages

		boolean containsP = false;
		visPackages = Pcept.getVisPackages(); // newly found packages

		for (int i = 0; i < visPackages.length; i++) {
			dest.add(new PosCalc(visPackages[i].getX(), visPackages[i].getY()));
			
			containsP = false;
			tPackages t = new tPackages(visPackages[i]);

			if(area[visPackages[i].getX()][visPackages[i].getY()]==0){
				tabPackages.add(t);
				area[visPackages[i].getX()][visPackages[i].getY()]=2;
				msgPackages.add(new tPackages(visPackages[i]));
			}
		}

		visAgents = Pcept.getVisAgents();// newly found agents
		// Pcept.printPercept();

		for (int i = 0; i < visAgents.length; i++) {
			if (visAgents[i].getId() == id) {// find oneself, update information
				current_x = visAgents[i].getX();
				current_y = visAgents[i].getY();
				last_x = current_x;
				last_y = current_y;
			}

			tAgents t = new tAgents(visAgents[i]);
			for (int e = Math.max(0, t.x - 7); e <= Math.min(worldSize - 1,
					t.x + 7); e++) {
				for (int f = Math.max(0, t.y - 7); f <= Math.min(worldSize - 1,
						t.y + 7); f++) {
					if (area[e][f] == 0)
						area[e][f] = 1;
				}
			}
		}

		/*
		for (int ee = 0; ee < worldSize; ee++) {
			for (int ff = 0; ff < worldSize; ff++) {
				if(area[ff][ee] == 0)
					System.out.print("*");
				if(area[ff][ee] == 1)
					System.out.print("_");
				if(area[ff][ee] == 2)
					System.out.print("#");
			}
			System.out.println();
		}
		System.out.println();
		
		// /////////////////////////////
		System.out.println("currentAt: (" + current_x +  "," + current_y + ")");
		System.out.println("Ux/Uy: (" + Ux+  "," + Uy + ")");
		
		for(int i=0;i<tabPackages.size();i++){
			System.out.println("PID = " + tabPackages.get(i).pid+" X = "+tabPackages.get(i).x + " Y = " + tabPackages.get(i).y
					+ " Ordered: " + Boolean.toString(tabPackages.get(i).isOrdered));
		}
		System.out.println("Ordered Package: " + ordered_package);
		*/
	} // end see
	

	boolean walk_to_package = false;// walk from current place to a package to
	// pick
	// it up
	boolean walk_to_destination = false;// walk from current place to a
	// destination to
	// drop a package
	boolean walk_to_unknown = false;// walk from current place to an unknown
	// area

	boolean pick_up = false;
	boolean drop_off = false;
	boolean cancel_reserve = false;

	public int direction(int current_x, int current_y, int dest_x, int dest_y) {

		if ((dest_x - current_x) == 0) {

			if ((dest_y - current_y) > 0)
				return 2;// south

			else if ((dest_y - current_y) < 0)
				return 0;// north
		}

		if ((dest_y - current_y) == 0) {

			if ((dest_x - current_x) > 0)
				return 1;// east

			else if ((dest_x - current_x) < 0)
				return 3;// west
		}

		if ((dest_y - current_y) < 0) {

			if ((dest_x - current_x) > 0) {
				return 4;// north east
			}

			if ((dest_x - current_x) < 0) {
				return 7;// north west
			}
		}

		if ((dest_y - current_y) > 0) {

			if ((dest_x - current_x) > 0) {
				return 5;// south east
			}

			if ((dest_x - current_x) < 0) {
				return 6;// south west
			}
		}

		return -1;
	}

	String said = "";

	public Action Sendmessage() {// send message about packages and agents
		String s = "";
		s += "P";// package information

		for (int i = 0; i < msgPackages.size(); i++) {
			s += "i";// package id
			s = s + Integer.toString(msgPackages.get(i).pid) + "x"
					+ msgPackages.get(i).x + "y" + msgPackages.get(i).y + "o"
					+ Boolean.toString(msgPackages.get(i).isOrdered) + "p"
					+ Boolean.toString(msgPackages.get(i).isPicked);
		}
		msgPackages.clear();

			s += "A";
			s += "i" + id;
			s += "x" + Integer.toString(current_x) + "y"
					+ Integer.toString(current_y)+"m";

		if (said.equals(s)) {
			Ux = -1;
			Uy = -1;
			return null;
		} else {
			said = s;
			return new Say(s);
		}
	}

	public boolean isNext(int a, int b, int x, int y) {// (a,b) is next to (x,y)

		if (Math.abs(a - x) + Math.abs(b - y) == 1) {
			return true;
		}

		else
			return false;
	}

	public boolean objN(int x, int y, int p_dir) {// if there is agent or package in the
		// north
		for (int i = 0; i < visAgents.length; i++) {
			if (p_dir == -1 && (
					(isOutofbound(new PosCalc(x, y - 1))) || 
						visAgents[i].getX() == x && visAgents[i].getY() == y - 1)) {
				return true;
			}
			
			if (p_dir == 0 && (
					(isOutofbound(new PosCalc(x, y - 2))) ||
						visAgents[i].getX() == x && visAgents[i].getY() == y - 2)) {
				return true;
			}
			
			if (p_dir == 1 && (
					(isOutofbound(new PosCalc(x, y - 1))) || 
					(isOutofbound(new PosCalc(x + 1, y - 1))) ||
						visAgents[i].getX() == x && visAgents[i].getY() == y - 1 ||
						visAgents[i].getX() == x + 1 && visAgents[i].getY() == y - 1)) {
				return true;
			}
			
			if (p_dir == 2 && (
					(isOutofbound(new PosCalc(x, y - 1))) || 
					visAgents[i].getX() == x && visAgents[i].getY() == y - 1)) {
				return true;
			}
			
			if (p_dir == 3 && (
					(isOutofbound(new PosCalc(x, y - 1))) || 
					(isOutofbound(new PosCalc(x - 1, y - 1))) ||
						visAgents[i].getX() == x && visAgents[i].getY() == y - 1 ||
						visAgents[i].getX() == x - 1 && visAgents[i].getY() == y - 1)) {
				return true;
			}
		}
		for (int i = 0; i < visPackages.length; i++) {
			if (p_dir == -1 && (
					(isOutofbound(new PosCalc(x, y - 1))) || 
						visPackages[i].getX() == x && visPackages[i].getY() == y - 1)) {
				return true;
			}
			
			if (p_dir == 0 && (
					(isOutofbound(new PosCalc(x, y - 2))) ||
						visPackages[i].getX() == x && visPackages[i].getY() == y - 2)) {
				return true;
			}
			
			if (p_dir == 1 && (
					(isOutofbound(new PosCalc(x, y - 1))) || 
					(isOutofbound(new PosCalc(x + 1, y - 1))) ||
						visPackages[i].getX() == x && visPackages[i].getY() == y - 1 ||
						visPackages[i].getX() == x + 1 && visPackages[i].getY() == y - 1)) {
				return true;
			}
			
			if (p_dir == 2 && (
					(isOutofbound(new PosCalc(x, y - 1))) || 
					visPackages[i].getX() == x && visPackages[i].getY() == y - 1)) {
				return true;
			}
			
			if (p_dir == 3 && (
					(isOutofbound(new PosCalc(x, y - 1))) || 
					(isOutofbound(new PosCalc(x - 1, y - 1))) ||
						visPackages[i].getX() == x && visPackages[i].getY() == y - 1 ||
						visPackages[i].getX() == x - 1 && visPackages[i].getY() == y - 1)) {
				return true;
			}
		}
		
		return false;
	}

	public boolean objS(int x, int y, int p_dir) {// if there is agent or package in the
		// south
		for (int i = 0; i < visAgents.length; i++) {
			if (p_dir == -1 && (
					(isOutofbound(new PosCalc(x, y + 1))) || 
						visAgents[i].getX() == x && visAgents[i].getY() == y + 1)) {
				return true;
			}
			
			if (p_dir == 0 && (
					(isOutofbound(new PosCalc(x, y + 1))) ||
						visAgents[i].getX() == x && visAgents[i].getY() == y + 1)) {
				return true;
			}
			
			if (p_dir == 1 && (
					(isOutofbound(new PosCalc(x, y + 1))) || 
					(isOutofbound(new PosCalc(x + 1, y + 1))) ||
						visAgents[i].getX() == x && visAgents[i].getY() == y + 1 ||
						visAgents[i].getX() == x + 1 && visAgents[i].getY() == y + 1)) {
				return true;
			}
			
			if (p_dir == 2 && (
					(isOutofbound(new PosCalc(x, y + 2))) || 
					visAgents[i].getX() == x && visAgents[i].getY() == y + 2)) {
				return true;
			}
			
			if (p_dir == 3 && (
					(isOutofbound(new PosCalc(x, y + 1))) || 
					(isOutofbound(new PosCalc(x - 1, y + 1))) ||
						visAgents[i].getX() == x && visAgents[i].getY() == y + 1 ||
						visAgents[i].getX() == x - 1 && visAgents[i].getY() == y + 1)) {
				return true;
			}
		}
		
		for (int i = 0; i < visPackages.length; i++) {
			if (p_dir == -1 && (
					(isOutofbound(new PosCalc(x, y + 1))) || 
						visPackages[i].getX() == x && visPackages[i].getY() == y + 1)) {
				return true;
			}
			
			if (p_dir == 0 && (
					(isOutofbound(new PosCalc(x, y + 1))) ||
						visPackages[i].getX() == x && visPackages[i].getY() == y + 1)) {
				return true;
			}
			
			if (p_dir == 1 && (
					(isOutofbound(new PosCalc(x, y + 1))) || 
					(isOutofbound(new PosCalc(x + 1, y + 1))) ||
						visPackages[i].getX() == x && visPackages[i].getY() == y + 1 ||
						visPackages[i].getX() == x + 1 && visPackages[i].getY() == y + 1)) {
				return true;
			}
			
			if (p_dir == 2 && (
					(isOutofbound(new PosCalc(x, y + 2))) || 
					visPackages[i].getX() == x && visPackages[i].getY() == y + 2)) {
				return true;
			}
			
			if (p_dir == 3 && (
					(isOutofbound(new PosCalc(x, y + 1))) || 
					(isOutofbound(new PosCalc(x - 1, y + 1))) ||
						visPackages[i].getX() == x && visPackages[i].getY() == y + 1 ||
						visPackages[i].getX() == x - 1 && visPackages[i].getY() == y + 1)) {
				return true;
			}
		}
		return false;
	}

	public boolean objE(int x, int y, int p_dir) {// if there is agent or package in the
		// east
		for (int i = 0; i < visAgents.length; i++) {
			if (p_dir == -1 && (
					(isOutofbound(new PosCalc(x + 1, y))) || 
						visAgents[i].getX() == x  + 1 && visAgents[i].getY() == y)) {
				return true;
			}
			
			if (p_dir == 0 && (
					(isOutofbound(new PosCalc(x + 1, y))) || 
					(isOutofbound(new PosCalc(x + 1, y - 1))) ||
						visAgents[i].getX() == x + 1 && visAgents[i].getY() == y ||
						visAgents[i].getX() == x + 1 && visAgents[i].getY() == y - 1)) {
				return true;
			}
			
			if (p_dir == 1 && (
					(isOutofbound(new PosCalc(x + 2, y))) ||
						visAgents[i].getX() == x + 2 && visAgents[i].getY() == y)) {
				return true;
			}
			
			if (p_dir == 2 && (
					(isOutofbound(new PosCalc(x + 1, y))) || 
					(isOutofbound(new PosCalc(x + 1, y + 1))) ||
						visAgents[i].getX() == x + 1 && visAgents[i].getY() == y ||
						visAgents[i].getX() == x + 1 && visAgents[i].getY() == y + 1)) {
				return true;
			}
			
			if (p_dir == 3 && (
					(isOutofbound(new PosCalc(x + 1, y))) || 
					visAgents[i].getX() == x + 1 && visAgents[i].getY() == y)) {
				return true;
			}
		}
		
		for (int i = 0; i < visPackages.length; i++) {
			if (p_dir == -1 && (
					(isOutofbound(new PosCalc(x + 1, y))) || 
						visPackages[i].getX() == x  + 1 && visPackages[i].getY() == y)) {
				return true;
			}
			
			if (p_dir == 0 && (
					(isOutofbound(new PosCalc(x + 1, y))) || 
					(isOutofbound(new PosCalc(x + 1, y - 1))) ||
						visPackages[i].getX() == x + 1 && visPackages[i].getY() == y ||
						visPackages[i].getX() == x + 1 && visPackages[i].getY() == y - 1)) {
				return true;
			}
			
			if (p_dir == 1 && (
					(isOutofbound(new PosCalc(x + 2, y))) ||
						visPackages[i].getX() == x + 2 && visPackages[i].getY() == y)) {
				return true;
			}
			
			if (p_dir == 2 && (
					(isOutofbound(new PosCalc(x + 1, y))) || 
					(isOutofbound(new PosCalc(x + 1, y + 1))) ||
						visPackages[i].getX() == x + 1 && visPackages[i].getY() == y ||
						visPackages[i].getX() == x + 1 && visPackages[i].getY() == y + 1)) {
				return true;
			}
			
			if (p_dir == 3 && (
					(isOutofbound(new PosCalc(x + 1, y))) || 
					visPackages[i].getX() == x + 1 && visPackages[i].getY() == y)) {
				return true;
			}
		}
		
		return false;
	}

	public boolean objW(int x, int y, int p_dir) {// if there is agent or package in the
		// west
		for (int i = 0; i < visAgents.length; i++) {
			if (p_dir == -1 && (
					(isOutofbound(new PosCalc(x - 1, y))) || 
						visAgents[i].getX() == x - 1 && visAgents[i].getY() == y)) {
				return true;
			}
	
			if (p_dir == 0 && (
					(isOutofbound(new PosCalc(x - 1, y))) || 
					(isOutofbound(new PosCalc(x - 1, y - 1))) ||
						visAgents[i].getX() == x - 1 && visAgents[i].getY() == y - 1 ||
						visAgents[i].getX() == x - 1 && visAgents[i].getY() == y)) {
				return true;
			}
			
			if (p_dir == 1 && (
					(isOutofbound(new PosCalc(x - 1, y))) ||
						visAgents[i].getX() == x - 1 && visAgents[i].getY() == y)) {
				return true;
			}
			
			if (p_dir == 2 && (
					(isOutofbound(new PosCalc(x - 1, y))) || 
					(isOutofbound(new PosCalc(x - 1, y + 1))) ||
						visAgents[i].getX() == x - 1 && visAgents[i].getY() == y ||
						visAgents[i].getX() == x - 1 && visAgents[i].getY() == y + 1)) {
				return true;
			}
			
			if (p_dir == 3 && (
					(isOutofbound(new PosCalc(x - 2, y))) || 
					visAgents[i].getX() == x - 2 && visAgents[i].getY() == y)) {
				return true;
			}
		}
		
		for (int i = 0; i < visPackages.length; i++) {
			if (p_dir == -1 && (
					(isOutofbound(new PosCalc(x - 1, y))) || 
						visPackages[i].getX() == x - 1 && visPackages[i].getY() == y)) {
				return true;
			}
	
			if (p_dir == 0 && (
					(isOutofbound(new PosCalc(x - 1, y))) || 
					(isOutofbound(new PosCalc(x - 1, y - 1))) ||
						visPackages[i].getX() == x - 1 && visPackages[i].getY() == y - 1 ||
						visPackages[i].getX() == x - 1 && visPackages[i].getY() == y)) {
				return true;
			}
			
			if (p_dir == 1 && (
					(isOutofbound(new PosCalc(x - 1, y))) ||
						visPackages[i].getX() == x - 1 && visPackages[i].getY() == y)) {
				return true;
			}
			
			if (p_dir == 2 && (
					(isOutofbound(new PosCalc(x - 1, y))) || 
					(isOutofbound(new PosCalc(x - 1, y + 1))) ||
						visPackages[i].getX() == x - 1 && visPackages[i].getY() == y ||
						visPackages[i].getX() == x - 1 && visPackages[i].getY() == y + 1)) {
				return true;
			}
			
			if (p_dir == 3 && (
					(isOutofbound(new PosCalc(x - 2, y))) || 
					visPackages[i].getX() == x - 2 && visPackages[i].getY() == y)) {
				return true;
			}
		}
		
		return false;
	}

	// according to the path that A star algorithm provides, generate a series
	// of acions
	private void generateAction() {

		for (int i = 0; i < path.length; i++) {
			if (path[i] == 0) {// if path is on the right of
				// current agent direction, turn
				// right
				// current_y -= 1;
				actions += "N";
				moves.add(new Move(0));
			}

			if (path[i] == 1) {// if path is on the back of
				// current agent direction,
				// turn right twice
				// current_x += 1;
				actions += "E";
				moves.add(new Move(1));
			}

			if (path[i] == 2) {// if path is on the left of current
				// agent direction, turn left
				// current_y += 1;
				actions += "S";
				moves.add(new Move(2));
			}

			if (path[i] == 3) {// if path is on the back of
				// current agent direction,
				// turn right twice
				// current_x -= 1;
				actions += "W";
				moves.add(new Move(3));
			}
		}
	}

	public Action rand_move() {// move randomly to possible area
		if (!objE(current_x, current_y, p_dir) && !objS(current_x, current_y, p_dir)
				&& !objW(current_x, current_y, p_dir) && !objN(current_x, current_y, p_dir)) {
			if (Math.random() <= 0.1) {
				last_action = new Move(Direction.EAST);
			}
			if (Math.random() <= 0.5 && Math.random() > 0.1) {
				last_action = new Move(Direction.NORTH);
			}
			if (Math.random() <= 0.8 && Math.random() > 0.5) {
				last_action = new Move(Direction.SOUTH);
			} else {
				last_action = new Move(Direction.WEST);
			}
		}
		if (objE(current_x, current_y, p_dir) && !objS(current_x, current_y, p_dir)
				&& !objW(current_x, current_y, p_dir) && !objN(current_x, current_y, p_dir)) {

			if (Math.random() <= 0.4 && Math.random() > 0) {
				last_action = new Move(Direction.NORTH);
			}
			if (Math.random() <= 0.8 && Math.random() > 0.4) {
				last_action = new Move(Direction.SOUTH);
			} else {
				last_action = new Move(Direction.WEST);
			}
		}
		if (!objE(current_x, current_y, p_dir) && objS(current_x, current_y, p_dir)
				&& !objW(current_x, current_y, p_dir) && !objN(current_x, current_y, p_dir)) {

			if (Math.random() <= 0.4 && Math.random() > 0) {
				last_action = new Move(Direction.NORTH);
			}
			if (Math.random() <= 0.8 && Math.random() > 0.4) {
				last_action = new Move(Direction.EAST);
			} else {
				last_action = new Move(Direction.WEST);
			}
		}
		if (!objE(current_x, current_y, p_dir) && !objS(current_x, current_y, p_dir)
				&& objW(current_x, current_y, p_dir) && !objN(current_x, current_y, p_dir)) {

			if (Math.random() <= 0.4 && Math.random() > 0) {
				last_action = new Move(Direction.NORTH);
			}
			if (Math.random() <= 0.8 && Math.random() > 0.4) {
				last_action = new Move(Direction.SOUTH);
			} else {
				last_action = new Move(Direction.EAST);
			}
		}
		if (!objE(current_x, current_y, p_dir) && !objS(current_x, current_y, p_dir)
				&& !objW(current_x, current_y, p_dir) && objN(current_x, current_y, p_dir)) {

			if (Math.random() <= 0.4 && Math.random() > 0) {
				last_action = new Move(Direction.EAST);
			}
			if (Math.random() <= 0.8 && Math.random() > 0.4) {
				last_action = new Move(Direction.SOUTH);
			} else {
				last_action = new Move(Direction.WEST);
			}
		}
		if (objE(current_x, current_y, p_dir) && objS(current_x, current_y, p_dir)
				&& !objW(current_x, current_y, p_dir) && !objN(current_x, current_y, p_dir)) {

			if (Math.random() <= 0.4 && Math.random() > 0) {
				last_action = new Move(Direction.NORTH);
			} else {
				last_action = new Move(Direction.WEST);
			}
		}
		if (objE(current_x, current_y, p_dir) && !objS(current_x, current_y, p_dir)
				&& objW(current_x, current_y, p_dir) && !objN(current_x, current_y, p_dir)) {

			if (Math.random() <= 0.4 && Math.random() > 0) {
				last_action = new Move(Direction.SOUTH);
			} else {
				last_action = new Move(Direction.NORTH);
			}
		}
		if (objE(current_x, current_y, p_dir) && !objS(current_x, current_y, p_dir)
				&& !objW(current_x, current_y, p_dir) && objN(current_x, current_y, p_dir)) {

			if (Math.random() <= 0.4 && Math.random() > 0) {
				last_action = new Move(Direction.NORTH);
			} else {
				last_action = new Move(Direction.WEST);
			}
		}
		if (!objE(current_x, current_y, p_dir) && objS(current_x, current_y, p_dir)
				&& objW(current_x, current_y, p_dir) && !objN(current_x, current_y, p_dir)) {

			if (Math.random() <= 0.4 && Math.random() > 0) {
				last_action = new Move(Direction.NORTH);
			} else {
				last_action = new Move(Direction.EAST);
			}
		}
		if (!objE(current_x, current_y, p_dir) && objS(current_x, current_y, p_dir)
				&& !objW(current_x, current_y, p_dir) && objN(current_x, current_y, p_dir)) {

			if (Math.random() <= 0.4 && Math.random() > 0) {
				last_action = new Move(Direction.EAST);
			} else {
				last_action = new Move(Direction.WEST);
			}
		}
		if (!objE(current_x, current_y, p_dir) && !objS(current_x, current_y, p_dir)
				&& objW(current_x, current_y, p_dir) && objN(current_x, current_y, p_dir)) {

			if (Math.random() <= 0.4 && Math.random() > 0) {
				last_action = new Move(Direction.SOUTH);
			} else {
				last_action = new Move(Direction.EAST);
			}
		} else {
			if (!objE(current_x, current_y, p_dir)) {
				last_action = new Move(Direction.EAST);
			}
			if (!objN(current_x, current_y, p_dir)) {
				last_action = new Move(Direction.NORTH);
			}
			if (!objW(current_x, current_y, p_dir)) {
				last_action = new Move(Direction.WEST);
			}
			if (!objS(current_x, current_y, p_dir)) {
				last_action = new Move(Direction.SOUTH);
			}
		}
		
		cancel_reserve = true;
		return last_action;
	}

	int dist(int x, int y, int a, int b) {// calculate distance between two
											// nodes
		return Math.abs(x - a) + Math.abs(y - b);
	}

	@Override
	public Action selectAction() {

		// TODO Auto-generated method stub

		if(cancel_reserve){
			cancel_reserve = false;
			if(Pcept.getHeldPackage() == null){
				if(ordered_package != null){
					ordered_package.isOrdered = false;
					ordered_package.isPicked = false;
					tabPackages.add(ordered_package);
					msgPackages.add(ordered_package);
					Ux = -1;
					Uy = -1;
					last_action = Sendmessage();
					ordered_package = null;
					return last_action;
				} else {
					Ux = -1;
					Uy = -1;
				}
			}
		}
		
		if (last_action instanceof Pickup) {// if last action is pick up, then
											// change aim to destination of
											// package
			VisiblePackage p = Pcept.getHeldPackage();
			if (p != null) {
				walk_to_destination = true;
				
				p_dir = direction(current_x,current_y,p.getX(),p.getY());
				if (area[Ux][Uy] == 2)
					area[Ux][Uy] = 1;

				ordered_package.isPicked = true;
				msgPackages.add(ordered_package);
			
				
				Ux = p.getDestX();
				Uy = p.getDestY();
				dest.add(new PosCalc(Ux, Uy));
				moves.clear();

				if (!msgPackages.isEmpty()) { // if new packages or new
					// agents are discovered,
					// send message
					last_action = Sendmessage();
					return last_action;
				}
			} else {
				Ux = -1;
				Uy = -1;
				
				area[ordered_package.x][ordered_package.y] =2;
				tabPackages.add(ordered_package);
				msgPackages.add(ordered_package);
				ordered_package = null;
				walk_to_destination = false;
				
				if (!msgPackages.isEmpty()) { // if new packages or new
					// agents are discovered,
					// send message
					last_action = Sendmessage();
					return last_action;
				}
			}
			

		}

		if (last_action instanceof Dropoff) {// if last action is dropoff, check
												// success or not. if not, add
												// the package again.
			
			boolean dropped = true;
			int pac = -1;
			for (int i = 0; i < visPackages.length; ++i) {
				if (dropped_package == visPackages[i].getId()) {
					dropped = false;
					pac = i;
				}
			}
			if (dropped) {
				p_dir = -1;
				moves.clear();
				ordered_package = null;
				Ux = -1;
				Uy = -1;
				walk_to_destination = false;
			} else {
				if(Pcept.getHeldPackage() == null){
					area[visPackages[pac].getX()][visPackages[pac].getY()] = 2;
					tPackages tp = new tPackages(visPackages[pac]);
					msgPackages.add(tp);
					tabPackages.add(tp);
					ordered_package = null;
					Ux = -1;
					Uy = -1;
					walk_to_destination = false;
					
					last_action = Sendmessage();
					return last_action;
				} else {
					drop_cnt ++ ;
					if(drop_cnt >= 2){
						drop_cnt = 0;
						drop_off = false;
						last_action = new Dropoff(direction(current_x, current_y, Pcept.getHeldPackage().getX(), Pcept.getHeldPackage().getY()));
						dropped_package = Pcept.getHeldPackage().getId();
						Ux = -1;
						Uy = -1;
						
						return last_action;
					}
					
					walk_to_destination = true;
					Ux = Pcept.getHeldPackage().getDestX();
					Uy = Pcept.getHeldPackage().getDestY();
				}
			}
		}

		if (!msgPackages.isEmpty()) {// if new packages or new agents are
			// discovered, send message

			last_action = Sendmessage();
			return last_action;
		}
		
		if (dist(current_x, current_y, 0, 0) <= 3
				|| dist(current_x, current_y, 0, worldSize) <= 3
				|| dist(current_x, current_y, worldSize, 0) <= 3
				|| dist(current_x, current_y, worldSize, worldSize) <= 3) {
			cor_cnt++;
		} else {
			cor_cnt = 0;
		}
		
		if (cor_cnt >= 5) {
			Ux = -1;
			Uy = -1;
		}

		if (last_action instanceof Move || last_action == null) {// check if got
																	// stuck or
																	// not, if
																	// so, drop
																	// package
																	// or move
																	// randomly
																	// and
																	// reconsider
																	// aim

			if (Pcept.getHeldPackage() != null) {
				if (!isNext(current_x, current_y, bmp_x, bmp_y)
						&& !(current_x == bmp_x && current_y == bmp_y)) {
					counter = 0;
				}
				if (counter >= 4
						&& (isNext(current_x, current_y, bmp_x, bmp_y) 
									|| (current_x == bmp_x && current_y == bmp_y))) {
					counter = 0;
					moves.clear();
					
					drop_off = false;

					last_action = new Dropoff(direction(current_x, current_y,
							Pcept.getHeldPackage().getX(), Pcept
									.getHeldPackage().getY()));
					Ux = -1;
					Uy = -1;
					dropped_package = Pcept.getHeldPackage().getId();
					return last_action;
				}
			}

			if (bump) {
				counter++;
				if (counter == 1) {
					bmp_x = current_x;
					bmp_y = current_y;
				}
				
/*
				walk_to_package = false;
				walk_to_unknown = false;

				last_action = rand_move();
				return last_action;
				*/
			}
		}

		// find an intention
		if (Ux == -1 && Uy == -1) {
			if (Pcept.getHeldPackage() == null) {
				startpos.x = current_x;
				startpos.y = current_y;
				
				findbox = new BFS(this);// use breadth search first algorithm to
				// find aim box
				findbox.setstartPos(startpos);
				findbox.startToSearch();

				endpos = findbox.getendPos();
				if (endpos == null) {
					Random r = new Random();
					int n = r.nextInt(dest.size());
					Ux = dest.get(n).x;
					Uy = dest.get(n).y;
					last_action = rand_move();
					return last_action;
				}
				
				if (lastpos.x == endpos.x && lastpos.y == endpos.y) {
				
					Random r = new Random();
					int next = r.nextInt(tabPackages.size());
					Ux = tabPackages.get(next).x;
					Uy = tabPackages.get(next).y;

				} else {
					Ux = endpos.x;
					Uy = endpos.y;
				}
				
				lastpos = endpos;
			}
		
//This end pos is an unknown area or an unreserved package
			if (isObstacle(endpos)) {// if the nearest package is nearer than the nearest unknown place, go for it
				walk_to_package = true;
				
				for (int i = 0; i < tabPackages.size(); i++) {
					if (tabPackages.get(i).x == Ux
							&& tabPackages.get(i).y == Uy) {
						tabPackages.get(i).isOrdered = true;
						msgPackages.add(tabPackages.get(i));
						
						ordered_package = tabPackages.remove(i);
					}
				}
				
				if (!msgPackages.isEmpty()){ // if new packages or new agents are discovered, // send message last_action =
					  last_action = Sendmessage(); 
					  return last_action; 
				}
				 
			} else if (isunKnown(endpos)) {// if go to the nearest unknown place
				walk_to_unknown = true;
			}
		}
	
		if (walk_to_package || walk_to_unknown) {// walk to nearest unknown are or nearest package
			if (isNext(current_x, current_y, Ux, Uy)) {// if is next to the aim
														// area, pickup package
														// or reconsider next
														// aim
				moves.clear();
				if (walk_to_package) {
					walk_to_package = false;
					pick_up = true;
				}

				if (walk_to_unknown) {
					walk_to_unknown = false;
				}
			} else {// change the 15*15 area around agent to be known

				if (moves.size() <= 0) {
					findpath = new Astar(this);
					path = findpath.startToSearch();
					if(path != null)
							generateAction();
				}
				
				if (moves.size() >= 1) {
					Action act = moves.get(0);// always get the first action from action array
					moves.remove(0);
					last_action = act;
					return last_action;
				} else {
//					last_action = rand_move();
//					return last_action;
				}
			}
		}

		if (walk_to_destination) {// use Astar to find a path to destination and
									// generate actions, the actions may change
									// though
			Ux = Pcept.getHeldPackage().getDestX();
			Uy = Pcept.getHeldPackage().getDestY();
			
			if(dist(current_x,current_y,Ux,Uy)== 4){
				for(int i=0;i<visAgents.length;i++){
					if(visAgents[i].getId() != id && visAgents[i].getX() == Ux &&visAgents[i].getY() == Uy){
						drop_off = false;
						last_action = new Dropoff(direction(current_x, current_y, Pcept.getHeldPackage().getX(), Pcept.getHeldPackage().getY()));
						dropped_package = Pcept.getHeldPackage().getId();
						
						return last_action;
					}
				}
				
				for(int i=0;i<visPackages.length;i++){
					if(visPackages[i].isHeld() == false &&visPackages[i].getX() == Ux &&visPackages[i].getY() == Uy){
						drop_off = false;
						last_action = new Dropoff(direction(current_x, current_y, Pcept.getHeldPackage().getX(), Pcept.getHeldPackage().getY()));
						dropped_package = Pcept.getHeldPackage().getId();
						
						return last_action;
					}
				}
			}
			
			if (isNext(current_x, current_y, Ux, Uy)) {
				walk_to_destination = false;
				drop_off = true;
			} else {
				if (moves.size() <= 0) {
					findpath = new Astar(this);
					path = findpath.startToSearch();
					if(path != null)
						generateAction();
				}

				if (moves.size() >= 1) {
					Action act = moves.get(0);// always get the first action from action array
					moves.remove(0);
					last_action = act;
					return last_action;
				} else {
//					last_action = rand_move();
//					return last_action;
				}
			}
		}
		
		if (pick_up) {// if pick up the package, walk to destination next
			pick_up = false;
			last_action = new Pickup(direction(current_x, current_y, Ux, Uy));
			return last_action;
		}
		
		if (drop_off) {//if drop of package, reconsider next move
			drop_off = false;
			last_action = new Dropoff(direction(current_x, current_y, Ux, Uy));
			dropped_package = Pcept.getHeldPackage().getId();
			return last_action;
		}

		Ux = -1;
		Uy = -1;
		last_action = rand_move();
		return last_action;
	}
}